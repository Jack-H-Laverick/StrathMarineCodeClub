<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>StrathMarineCodeClub</title>

		<meta name="description" content="A HTML based walkthrough of key content from the Marine Code Club">
		<meta name="author" content="Jack H Laverick">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/my.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>

	<body>

		<div class="reveal"><!-- Any section element inside of this container is displayed as a slide -->

			<div class="slides">

				<section>
					<h1>StrathMarine</h1>
					<h1>CodeClub</h1>
					<h4>Cleaner coding in <img src="https://www.r-project.org/Rlogo.png" alt="R stats logo" style="height: 50px; margin: 0 auto 0rem auto; background: transparent;" class="demo-logo"></h4>
					<p>
						<small>Built with <a href="https://revealjs.com">reveal.js</a></small>
					</p>
				</section><!-- Title slide -->

				<section data-auto-animate>
					<h2 data-id="code-title">The Gifted Script</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers>
rm(list=ls())
setwd("D:/Z_Teaching and outreach/2021 Code club")

P <- as.matrix(read.csv("Sudoku.csv", header = F))

while (is.na(mean(P))) {
  
  for (i in c(1,2,3,4,5,6,7,8,9)) {

    for (j in c(1,2,3,4,5,6,7,8,9)) {
    
      if (is.na(P[i,j])) {

      r <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[i,], 0L) == 0L]
 
      c <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[,j], 0L) == 0L]
  
        if ((i-1) %/% 3 == 0 & (j-1) %/% 3 == 0)  {

          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(1,2,3),c(1,2,3)], 0L) == 0L]
    
        }
  
        if ((i-1) %/% 3 == 1 & (j-1) %/% 3 == 0)  {
    
          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(4,5,6),c(1,2,3)], 0L) == 0L]
    
        }
  
        if ((i-1) %/% 3 == 2 & (j-1) %/% 3 == 0)  {
    
          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(7,8,9),c(1,2,3)], 0L) == 0L]
    
        }
  
        if ((i-1) %/% 3 == 0 & (j-1) %/% 3 == 1)  {
    
          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(1,2,3),c(4,5,6)], 0L) == 0L]
          
        }
  
        if ((i-1) %/% 3 == 1 & (j-1) %/% 3 == 1)  {
    
          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(4,5,6),c(4,5,6)], 0L) == 0L]
    
        }
  
        if ((i-1) %/% 3 == 2 & (j-1) %/% 3 == 1)  {
    
          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(7,8,9),c(4,5,6)], 0L) == 0L]
    
        }
  
        if ((i-1) %/% 3 == 0 & (j-1) %/% 3 == 2)  {
    
          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(1,2,3),c(7,8,9)], 0L) == 0L]
    
        }
  
        if ((i-1) %/% 3 == 1 & (j-1) %/% 3 == 2)  {
    
          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(4,5,6),c(7,8,9)], 0L) == 0L]
    
        }
    
        if ((i-1) %/% 3 == 2 & (j-1) %/% 3 == 2)  {
    
          b <- c(1,2,3,4,5,6,7,8,9)[match(c(1,2,3,4,5,6,7,8,9), P[c(7,8,9),c(7,8,9)], 0L) == 0L]
    
        }

 a <- b[b %in% r[r %in% c]]

        if (length(a) == 1 ){ 
          
          if(!is.na(a)) P[i,j] <- a ; print(c(i,j))  
          
        }
      }
    }
  }  
}

for (i in c(1,2,3,4,5,6,7,8,9)) {

  print(sum(P[i,]))  
}

for (j in c(1,2,3,4,5,6,7,8,9)) {
  
  print(sum(P[,j]))  
}

Pold <- as.matrix(read.csv("Sudoku.csv", header = F))					</code></pre>
					<p>Code syntax highlighting courtesy of <a href="https://highlightjs.org/usage/">highlight.js</a>.</p>
				</section><!-- Gifted Script -->

				<section data-auto-animate>
					<h2 data-id="code-title">Week One</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|4,8-11|17|22-24"><script type="text/template">
#--# Title: Sudoku solver, 18/02/2022

#### Set up ####

rm(list=ls())                                                       # Clear the environment
setwd("D:/Z_Teaching and outreach/2021 Code club")                  # Set working directory

#### Solve Sudoku ####

Puzzle <- as.matrix(read.csv("Sudoku.csv", header = F))             # Import a Sudoku puzzle

while (is.na(mean(Puzzle))) {                                       # Run while there a gaps to be filled                                                                                   
  
  for (row in 1:9) {                                                # Work through the rows

    for (column in 1:9) {                                           # and the columns
    
      if (is.na(Puzzle[row, column])) {                             # Select a cell, Is the cell filled?

      row.poss <- c(1:9)[match(1:9, Puzzle[row,], 0L) == 0L]        # Find possible values for the cell in this row.
 
      col.poss <- c(1:9)[match(1:9, Puzzle[, column], 0L) == 0L]    # Find possible values for the cell in this column.
  
        if ((row-1) %/% 3 == 0 & (column-1) %/% 3 == 0)  {          # Is our cell in the top left box?

          box.poss <-c(1:9)[match(1:9, Puzzle[1:3, 1:3], 0L) == 0L] # Find possible values for the cell in this box
    
        }
  
        if ((row - 1) %/% 3 == 1 & (column - 1) %/% 3 == 0)  {      # Repeat for each other possible box
    
          box.poss <- c(1:9)[match(1:9, Puzzle[4:6, 1:3], 0L) == 0L]
    
        }
  
        if ((row - 1) %/% 3 == 2 & (column - 1) %/% 3 == 0)  {
    
          box.poss <- c(1:9)[match(1:9, Puzzle[7:9, 1:3], 0L) == 0L]
    
        }
  
        if ((row - 1) %/% 3 == 0 & (column - 1) %/% 3 == 1)  {
    
          box.poss <- c(1:9)[match(1:9, Puzzle[1:3, 4:6], 0L) == 0L]
          
        }
  
        if ((row - 1) %/% 3 == 1 & (column - 1) %/% 3 == 1)  {
    
          box.poss <- c(1:9)[match(1:9, Puzzle[4:6, 4:6], 0L) == 0L]
    
        }
  
        if ((row - 1) %/% 3 == 2 & (column - 1) %/% 3 == 1)  {
    
          box.poss <- c(1:9)[match(1:9, Puzzle[7:9, 4:6], 0L) == 0L]
    
        }
  
        if ((row - 1) %/% 3 == 0 & (column - 1) %/% 3 == 2)  {
    
          box.poss <- c(1:9)[match(1:9, Puzzle[1:3, 7:9], 0L) == 0L]
    
        }
  
        if ((row - 1) %/% 3 == 1 & (column - 1) %/% 3 == 2)  {
    
          box.poss <- c(1:9)[match(1:9, Puzzle[4:6, 7:9], 0L) == 0L]
    
        }
    
        if ((row - 1) %/% 3 == 2 & (column - 1) %/% 3 == 2)  {
    
          box.poss <- c(1:9)[match(1:9, Puzzle[7:9, 7:9], 0L) == 0L]
    
        }

 all.poss <- box.poss[box.poss %in% row.poss[row.poss %in% col.poss]] # Find the possible values using all conditions

        if (length(all.poss) == 1 ){                                  # If there is only 1 possible
          
          if(!is.na(all.poss)) Puzzle[row, column] <- all.poss ; print(c(row, column)) # Insert the number in the cell and print position
          
        }
      }
    }
  }  
}

#### Sense checking solution ####

for (row in 1:9) {                                                    # Check whether all rows sum to the same value

  print(sum(Puzzle[row,]))  
}

for (column in 1:9) {                                                 # Check whether all columns sum to the same value
  
  print(sum(Puzzle[, column]))  
}

Pold <- as.matrix(read.csv("Sudoku.csv", header = F))                 # reimport the original puzzle					</script></code></pre>
				</section><!-- Week 1 -->

				<section data-auto-animate>
					<h2 data-id="code-title">Week Two</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|4,8-11|17|22-24"><script type="text/template">
#--# Title: Sudoku solver, 25/02/2022

#### My functions ####

Find_possible_values <- function(Filled_already) {
  
  Possibles <- which(!1:9 %in% Filled_already)         # Return the values currently missing from Filled_already
  
  return(Possibles)
}

#### Solve Sudoku ####

Puzzle <- as.matrix(read.csv("./Data/Sudoku.csv", header = F))      # Import a Sudoku puzzle

while (anyNA(Puzzle)) {                                              # Run while there a gaps to be filled                                                                                   
  
  for (row in 1:9) {                                                 # Work through the rows

    for (column in 1:9) {                                            # and the columns
    
      if (is.na(Puzzle[row, column])) {                              # Select a cell, Is the cell filled?

      row.poss <- Find_possible_values(Puzzle[row,])                 # Find possible values for the cell in this row.
 
      col.poss <- Find_possible_values(Puzzle[,column])              # Find possible values for the cell in this column.
  
        if ((row-1) %/% 3 == 0 & (column-1) %/% 3 == 0)  {           # Is our cell in the top left box?

          box.poss <- Find_possible_values(Puzzle[1:3, 1:3])         # Find possible values for the cell in this box
    
        }
  
        if ((row - 1) %/% 3 == 1 & (column - 1) %/% 3 == 0)  {      # Repeat for each other possible box
    
          box.poss <- Find_possible_values(Puzzle[4:6, 1:3])
        }
  
        if ((row - 1) %/% 3 == 2 & (column - 1) %/% 3 == 0)  {
    
          box.poss <- Find_possible_values(Puzzle[7:9, 1:3])    
        }
  
        if ((row - 1) %/% 3 == 0 & (column - 1) %/% 3 == 1)  {
    
          box.poss <- Find_possible_values(Puzzle[1:3, 4:6])          
        }
  
        if ((row - 1) %/% 3 == 1 & (column - 1) %/% 3 == 1)  {
    
          box.poss <- Find_possible_values(Puzzle[4:6, 4:6])    
        }
  
        if ((row - 1) %/% 3 == 2 & (column - 1) %/% 3 == 1)  {
    
          box.poss <- Find_possible_values(Puzzle[7:9, 4:6])    
        }
  
        if ((row - 1) %/% 3 == 0 & (column - 1) %/% 3 == 2)  {
    
          box.poss <- Find_possible_values(Puzzle[1:3, 7:9])    
        }
  
        if ((row - 1) %/% 3 == 1 & (column - 1) %/% 3 == 2)  {
    
          box.poss <- Find_possible_values(Puzzle[4:6, 7:9])    
        }
    
        if ((row - 1) %/% 3 == 2 & (column - 1) %/% 3 == 2)  {
    
          box.poss <- Find_possible_values(Puzzle[7:9, 7:9])    
        }

 all.poss <- box.poss[box.poss %in% row.poss[row.poss %in% col.poss]] # Find the possible values using all conditions

        if (length(all.poss) == 1 ){                                  # If there is only 1 possible
          
          if(!is.na(all.poss)) Puzzle[row, column] <- all.poss ; print(c(row, column)) # Insert the number in the cell and print position
          
        }
      }
    }
  }  
}

#### Sense checking solution ####

for (row in 1:9) {                                                    # Check whether all rows sum to the same value

  print(sum(Puzzle[row,]))  
}

for (column in 1:9) {                                                 # Check whether all columns sum to the same value
  
  print(sum(Puzzle[, column]))  
}

Pold <- as.matrix(read.csv("./Data/Sudoku.csv", header = F))                 # reimport the original puzzle </script></code></pre>
				</section><!-- Week 2 -->

				<section data-auto-animate>
					<h2 data-id="code-title">Week Three</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|4,8-11"><script type="text/template">
#--# Title: Sudoku solver, 04/03/2022

#### My functions ####

Find_possible_values <- function(Filled_already) {

  if(length(Filled_already) != 9) stop("Not 9 values supplied") # Return error if we don't pass 9 values
  
  Possibles <- which(!1:9 %in% Filled_already)                  # Return the values currently missing from Filled_already
  
  return(Possibles)
}

Find_box <- function(row_or_column) {

  test <- (row_or_column-1) %/% 3                                        # Find the box for current cell
  to_select <- 0:8 %/% 3 == test                                         # Find other cells in the same box

  return(to_select)  
}

#### Solve Sudoku ####

Puzzle <- as.matrix(read.csv("./Data/Sudoku.csv", header = F))      # Import a Sudoku puzzle

while (anyNA(Puzzle)) {                                             # Run while there a gaps to be filled                                                                                   
  
  for (row in 1:9) {                                                # Work through the rows

    for (column in 1:9) {                                           # and the columns
    
      if (is.na(Puzzle[row, column])) {                             # Select a cell, Is the cell filled?

      row.poss <- Find_possible_values(Puzzle[row,])                # Find possible values for the cell in this row.
 
      col.poss <- Find_possible_values(Puzzle[,column])             # Find possible values for the cell in this column.

      box.poss <- Find_possible_values(Puzzle[Find_box(row), Find_box(column)]) # Find possible values for the cell in this box
      
      all.poss <- box.poss[box.poss %in% row.poss[row.poss %in% col.poss]] # Find the possible values using all conditions

      if (length(all.poss) == 1 ){                                  # If there is only 1 possible
        
        if(!is.na(all.poss)) Puzzle[row, column] <- all.poss ; print(c(row, column)) # Insert the number in the cell and print position
          
        }
      }
    }
  }  
}

#### Sense checking solution ####

rowSums(Puzzle)                                                     # Check whether all rows sum to the same value
colSums(Puzzle)                                                     # Check whether all columns sum to the same value
  
Pold <- as.matrix(read.csv("./Data/Sudoku.csv", header = F))        # reimport the original puzzle					</script></code></pre>
				</section><!-- Week 3 -->

				<section data-auto-animate>
					<h2 data-id="code-title">Week Four</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|4,8-11"><script type="text/template">
#--# Title: Sudoku solver, 18/03/2022

Puzzle <- as.matrix(read.csv("./Data/Sudoku.csv", header = F))                      # Import a Sudoku puzzle

Many_puzzles <- list(Puzzle)                                      
Many_puzzles <- Many_puzzles[rep(1, 10)]                                            # Create an example list of multiple puzzles

#### My functions ####

Find_possible_values <- function(Filled_already) {

  if(length(Filled_already) != 9) stop("Not 9 values supplied") # Return error if we don't pass 9 values
  
  Possibles <- which(!1:9 %in% Filled_already)                  # Return the values currently missing from Filled_already
  
  return(Possibles)
}

Find_box <- function(row_or_column) {

  test <- (row_or_column-1) %/% 3                                        # Find the box for current cell
  to_select <- 0:8 %/% 3 == test                                         # Find other cells in the same box

  return(to_select)  
}

Sudoku_solver <- function(Puzzle) {
  
  while (anyNA(Puzzle)) {                                                             # Run while there a gaps to be filled                                                                                   
    
    for (row in 1:9) {                                                                # Work through the rows
      
      for (column in 1:9) {                                                           # and the columns
        
        if (is.na(Puzzle[row, column])) {                                             # Select a cell, Is the cell filled?
          
          row.poss <- Find_possible_values(Puzzle[row,])                              # Find possible values for the cell in this row.
          
          col.poss <- Find_possible_values(Puzzle[,column])                           # Find possible values for the cell in this column.
          
          box.poss <- Find_possible_values(Puzzle[Find_box(row), Find_box(column)])   # Find possible values for the cell in this box
          
          all.poss <- box.poss[box.poss %in% row.poss[row.poss %in% col.poss]]        # Find the possible values using all conditions
          
          if (length(all.poss) == 1 & !is.na(all.poss) ){                             # If there is only 1 possible value
            
            Puzzle[row, column] <- all.poss                                           # Insert the number in the cell
            print(c(row, column))                                                     # print position
          }
        }
      }
    }  
  }
  return(Puzzle)}

#### Solve Sudoku ####

Solved_puzzle <- Sudoku_solver(Puzzle)                                              # Use our solver wrapped in a function

rowSums(Solved_puzzle)                                                              # Check whether all rows sum to the same value
colSums(Solved_puzzle)                                                              # Check whether all columns sum to the same value

#### Iterating over multiple puzzles ####

Many_solved <- lapply(Many_puzzles, Sudoku_solver)                                  # Using lapply (baseR)

Many_solved_map <- purrr::map(Many_puzzles, Sudoku_solver)                          # Using map (tidyverse)

furrr::plan("multisession")                                                         # In parallel (using furrr)
Many_solved_parallel <- furrr::future_map(Many_puzzles, Sudoku_solver)					</script></code></pre>
				</section><!-- Week 4 -->

				<section data-auto-animate>
					<h2 data-id="code-title">Week Five</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|4,8-11"><script type="text/template">
#--# Title: Sudoku solver, 25/03/2022

#### Set up ####

library(tidyverse) 
library(furrr)
library(tictoc)
library(microbenchmark)
library(profvis)                                                                    

plan("multisession")

Puzzle <- as.matrix(read.csv("./Data/Sudoku.csv", header = F))           # Import a Sudoku puzzle

Many_puzzles <- list(Puzzle)                                      
Many_puzzles <- Many_puzzles[rep(1, 10)]                                 # Create an example list of multiple puzzles

#### My functions ####

Find_possible_values <- function(Filled_already) {

  if(length(Filled_already) != 9) stop("Not 9 values supplied")          # Return error if we don't pass 9 values
  
  Possibles <- which(!1:9 %in% Filled_already)                           # Return the values currently missing from Filled_already
  
  return(Possibles)
}

Find_box <- function(row_or_column) {

  test <- (row_or_column-1) %/% 3                                        # Find the box for current cell
  to_select <- 0:8 %/% 3 == test                                         # Find other cells in the same box

  return(to_select)  
}

Sudoku_solver <- function(Puzzle) {
  
  while (anyNA(Puzzle)) {                                                             # Run while there a gaps to be filled                                                                                   
    
    for (row in 1:9) {                                                                # Work through the rows
      
      for (column in 1:9) {                                                           # and the columns
        
        if (is.na(Puzzle[row, column])) {                                             # Select a cell, Is the cell filled?
          
          row.poss <- Find_possible_values(Puzzle[row,])                              # Find possible values for the cell in this row.
          
          col.poss <- Find_possible_values(Puzzle[,column])                           # Find possible values for the cell in this column.
          
          box.poss <- Find_possible_values(Puzzle[Find_box(row), Find_box(column)])   # Find possible values for the cell in this box
          
          all.poss <- box.poss[box.poss %in% row.poss[row.poss %in% col.poss]]        # Find the possible values using all conditions
          
          if (length(all.poss) == 1 & !is.na(all.poss) ){                             # If there is only 1 possible value
            
            Puzzle[row, column] <- all.poss                                           # Insert the number in the cell
            print(c(row, column))                                                     # print position
          }
        }
      }
    }  
  }
  return(Puzzle)}

Sudoku_solver_np <- function(Puzzle) {
  
  while (anyNA(Puzzle)) {                                                             # Run while there a gaps to be filled                                                                                   
    
    for (row in 1:9) {                                                                # Work through the rows
      
      for (column in 1:9) {                                                           # and the columns
        
        if (is.na(Puzzle[row, column])) {                                             # Select a cell, Is the cell filled?
          
          row.poss <- Find_possible_values(Puzzle[row,])                              # Find possible values for the cell in this row.
          
          col.poss <- Find_possible_values(Puzzle[,column])                           # Find possible values for the cell in this column.
          
          box.poss <- Find_possible_values(Puzzle[Find_box(row), Find_box(column)])   # Find possible values for the cell in this box
          
          all.poss <- box.poss[box.poss %in% row.poss[row.poss %in% col.poss]]        # Find the possible values using all conditions
          
          if (length(all.poss) == 1 & !is.na(all.poss) ){                             # If there is only 1 possible value
            
            Puzzle[row, column] <- all.poss                                           # Insert the number in the cell
#            print(c(row, column))                                                    # print position
          }
        }
      }
    }  
  }
  return(Puzzle)}                                                                   # Turn off printing in the function

#### Benchmarking ####

tic()
Solved_puzzle <- Sudoku_solver(Puzzle)                                              # Simple way to time code
toc()

microbenchmark(Sudoku_solver(Puzzle))                                               # Timing repeated evaluations for performance statistics

Bench_printing <- microbenchmark(printing = Sudoku_solver(Puzzle),                  # What happens if we turn off the printing?
                                 no_printing = Sudoku_solver_np(Puzzle))

autoplot(Bench_printing)                                                            # Visually inspect performance differences

#### Profiling iterators  ####

Multi_Bench <- microbenchmark(lapply = lapply(Many_puzzles, Sudoku_solver),         # Comparing different versions of the same code
                              map = map(Many_puzzles, Sudoku_solver),
                              parallel = future_map(Many_puzzles, Sudoku_solver),
                              times = 10)                                           # Control the number of repeats

autoplot(Multi_Bench)                                                               # Why is code in parallel slower?

profvis({                                                                           # Identify the bottlenecks with code profiling
  future_map(Many_puzzles, Sudoku_solver)                                           # Lots of the runtime is committed to copying the data
})					</script></code></pre>
				</section><!-- Week 5 -->

				<section data-auto-animate>
					<h2 data-id="code-title">Week Sixa</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|4,8-11"><script type="text/template">
#--# Title: Sudoku solver, 01/04/2022

#### Set up ####

#source("./R scripts/Session 6b.R") 
## OR
library(sudokusolver)

Puzzle <- as.matrix(read.csv("./Data/Sudoku.csv", header = F))                  # Import a Sudoku puzzle

Many_puzzles <- list(Puzzle)                                      
Many_puzzles <- Many_puzzles[rep(1, 10)]                                        # Create an example list of multiple puzzles

#### Solve many sudoku puzzles ####

Solved <- lapply(Many_puzzles, Sudoku_solver_np)					</script></code></pre>
				</section><!-- Week 6a -->

				<section data-auto-animate>
					<h2 data-id="code-title">Week Sixb</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|4,8-11"><script type="text/template">
#--# Title: Functions to solve a sudoku puzzle

Find_possible_values <- function(Filled_already) {

  if(length(Filled_already) != 9) stop("Not 9 values supplied") # Return error if we don't pass 9 values
  
  Possibles <- which(!1:9 %in% Filled_already)                  # Return the values currently missing from Filled_already
  
  return(Possibles)
}

Find_box <- function(row_or_column) {

  test <- (row_or_column-1) %/% 3                                        # Find the box for current cell
  to_select <- 0:8 %/% 3 == test                                         # Find other cells in the same box

  return(to_select)  
}

Sudoku_solver <- function(Puzzle) {
  
  while (anyNA(Puzzle)) {                                                             # Run while there a gaps to be filled                                                                                   
    
    for (row in 1:9) {                                                                # Work through the rows
      
      for (column in 1:9) {                                                           # and the columns
        
        if (is.na(Puzzle[row, column])) {                                             # Select a cell, Is the cell filled?
          
          row.poss <- Find_possible_values(Puzzle[row,])                              # Find possible values for the cell in this row.
          
          col.poss <- Find_possible_values(Puzzle[,column])                           # Find possible values for the cell in this column.
          
          box.poss <- Find_possible_values(Puzzle[Find_box(row), Find_box(column)])   # Find possible values for the cell in this box
          
          all.poss <- box.poss[box.poss %in% row.poss[row.poss %in% col.poss]]        # Find the possible values using all conditions
          
          if (length(all.poss) == 1 & !is.na(all.poss) ){                             # If there is only 1 possible value
            
            Puzzle[row, column] <- all.poss                                           # Insert the number in the cell
            print(c(row, column))                                                     # print position
          }
        }
      }
    }  
  }
  return(Puzzle)}

Sudoku_solver_np <- function(Puzzle) {
  
  while (anyNA(Puzzle)) {                                                             # Run while there a gaps to be filled                                                                                   
    
    for (row in 1:9) {                                                                # Work through the rows
      
      for (column in 1:9) {                                                           # and the columns
        
        if (is.na(Puzzle[row, column])) {                                             # Select a cell, Is the cell filled?
          
          row.poss <- Find_possible_values(Puzzle[row,])                              # Find possible values for the cell in this row.
          
          col.poss <- Find_possible_values(Puzzle[,column])                           # Find possible values for the cell in this column.
          
          box.poss <- Find_possible_values(Puzzle[Find_box(row), Find_box(column)])   # Find possible values for the cell in this box
          
          all.poss <- box.poss[box.poss %in% row.poss[row.poss %in% col.poss]]        # Find the possible values using all conditions
          
          if (length(all.poss) == 1 & !is.na(all.poss) ){                             # If there is only 1 possible value
            
            Puzzle[row, column] <- all.poss                                           # Insert the number in the cell
#            print(c(row, column))                                                    # print position
          }
        }
      }
    }  
  }
  return(Puzzle)}                                                                     # Turn off printing in the function					</script></code></pre>
				</section><!-- Week 6b -->

				<section data-auto-animate>
					<h2 data-id="code-title">Week Sixc</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|4,8-11"><script type="text/template">
#--# Title: Building an R package, 01/04/2022

library(devtools)

create("./sudokusolver", open = TRUE) # Get the package started

# Update DESCRIPTION file

# Move across your functions into the R directory

# Document the functions using roxygen2, including adding an export tag

document()  # Build help pages

install()   # Install our package ready for use 					</script></code></pre>
				</section><!-- Week 6c -->

			</div>

		</div> <!-- Any section element inside of this container is displayed as a slide -->

		<script src="dist/reveal.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/search/search.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

		</script>

	</body>
	
</html>
